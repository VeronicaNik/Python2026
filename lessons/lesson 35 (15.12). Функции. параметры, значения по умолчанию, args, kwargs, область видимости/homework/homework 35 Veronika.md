# Домашняя работа: Функции. Параметры, значения по умолчанию, args, kwargs, область видимости

## Задачи
1. **Функция для расчета стоимости доставки**
   - **Описание задачи:** Создайте функцию, которая рассчитывает стоимость доставки. Это упражнение закрепляет базовые навыки объявления функций, передачи аргументов и использования оператора `return`. Вы научитесь отличать параметры от аргументов и правильно возвращать результат вычислений.
   - **Пример (вход → выход):**
     - `calculate_delivery(5, "Москва")` → `400` (базовая стоимость 300 + 20*5)
     - `calculate_delivery(2, "Казань", urgent=True)` → `560` (срочная: 500 + 30*2)
     - `calculate_delivery(0, "СПб")` → `300` (базовая стоимость, даже если вес 0)
   - **Критерии проверки и ограничения:**
     - Функция должна принимать три параметра: `weight_kg` (вес в кг), `city` (город), `urgent` (срочная доставка, по умолчанию `False`).
     - Формула: базовая стоимость 300 + 20 * `weight_kg`. Если `urgent` равен `True`, то базовая стоимость 500 + 30 * `weight_kg`.
     - Функция должна возвращать целое число (результат расчета). Не используйте `print` внутри функции для вывода результата.
   - **Решение (псевдокод):**
     1. Объявить функцию с тремя параметрами: `weight_kg`, `city`, `urgent` (последнему задать значение по умолчанию `False`).
     2. Внутри функции проверить, равен ли `urgent` `True`.
     3. Если да, вычислить результат как `500 + 30 * weight_kg`.
     4. Если нет, вычислить результат как `300 + 20 * weight_kg`.
     5. Вернуть вычисленный результат.
   - **Рекомендации:**
     - Используйте понятные имена параметров.
     - Следите за отступами (4 пробела) внутри функции.

2. **Безопасное добавление заметок в список**
   - **Описание задачи:** Создайте функцию для добавления заметки в список. Задача направлена на понимание и предотвращение распространенной ошибки — использования изменяемого объекта (списка) в качестве значения по умолчанию для параметра.
   - **Пример (вход → выход):**
     - `add_note("Купить молоко")` → `['Купить молоко']`
     - `add_note("Позвонить маме")` → `['Позвонить маме']` (каждый вызов создает новый список, а не добавляет в старый)
     - `my_list = []; add_note("Задача 1", my_list)` → `['Задача 1']` (переданный список изменяется)
   - **Критерии проверки и ограничения:**
     - Функция должна принимать два параметра: `note_text` (текст заметки) и `notes_list` (список для заметок, значение по умолчанию — `None`).
     - Если `notes_list` равен `None`, внутри функции нужно создать новый пустой список.
     - Добавить `note_text` в список `notes_list`.
     - Функция должна возвращать измененный список `notes_list`.
   - **Решение (псевдокод):**
     1. Объявить функцию с параметрами `note_text` и `notes_list` (значение по умолчанию `None`).
     2. Внутри функции проверить, равен ли `notes_list` `None`.
     3. Если да, создать новый пустой список и присвоить его переменной `notes_list`.
     4. Добавить `note_text` в список `notes_list`.
     5. Вернуть список `notes_list`.
   - **Рекомендации:**
     - Для проверки на `None` используйте оператор `is` (`if notes_list is None:`).
     - Избегайте использования изменяемых объектов (списков, словарей) в качестве значений по умолчанию. Всегда используйте `None` и создавайте объект внутри функции.

3. **Функция для сбора информации о студенте**
   - **Описание задачи:** Создайте функцию, которая собирает информацию о студенте, используя `*args` для хобби и `**kwargs` для дополнительных данных. Упражнение тренирует работу с переменным числом аргументов.
   - **Пример (вход → выход):**
     - `create_student_profile("Вероника", "Python", "рисование", city="Казань")` → `{'name': 'Вероника', 'hobbies': ('Python', 'рисование'), 'city': 'Казань'}`
     - `create_student_profile("Алексей")` → `{'name': 'Алексей', 'hobbies': (), 'extra': {}}`
     - `create_student_profile("Мария", "музыка", age=20, course=1)` → `{'name': 'Мария', 'hobbies': ('музыка',), 'age': 20, 'course': 1}`
   - **Критерии проверки и ограничения:**
     - Функция должна принимать один обязательный позиционный параметр `name`, затем `*args` (для хобби), и `**kwargs` (для любой другой информации).
     - Функция должна возвращать словарь с ключами: `"name"` (значение из параметра), `"hobbies"` (кортеж из `*args`). Все остальные ключи из `**kwargs` должны быть добавлены в этот же словарь.
     - Если `**kwargs` пуст, не добавляйте в результат отдельный ключ для него.
   - **Решение (псевдокод):**
     1. Объявить функцию с параметрами `name`, `*args`, `**kwargs`.
     2. Создать словарь `profile`.
     3. Добавить в `profile` ключ `"name"` со значением `name`.
     4. Добавить в `profile` ключ `"hobbies"` со значением кортежа из `args`.
     5. Для каждой пары ключ-значение в `kwargs` добавить эту пару в словарь `profile`.
     6. Вернуть словарь `profile`.
   - **Рекомендации:**
     - Помните, что `args` — это кортеж. Его можно использовать как есть.
     - Для перебора `kwargs` используйте цикл по `.items()`.

4. **Локальный счетчик внутри функции**
   - **Описание задачи:** Создайте функцию, которая ведет подсчет своих вызовов, используя область видимости для хранения состояния. Это упражнение знакомит с понятием замыкания (функция, запоминающая внешние переменные) без использования `global`.
   - **Пример (вход → выход):**
     - `counter1 = make_counter(); counter1()` → `1`
     - `counter1()` → `2`
     - `counter2 = make_counter(); counter2()` → `1` (новый независимый счетчик)
     - `counter1()` → `3` (первый счетчик продолжает с своего значения)
   - **Критерии проверки и ограничения:**
     - Создайте функцию `make_counter`, которая не принимает аргументов.
     - Внутри `make_counter` объявите переменную `count` и инициализируйте ее нулем.
     - Внутри `make_counter` объявите и верните другую функцию (назовем ее `increment`).
     - Функция `increment` также не принимает аргументов. При каждом вызове она должна увеличивать `count` на 1 и возвращать новое значение.
     - Переменная `count` должна быть локальной для `make_counter` и "запоминаться" внутренней функцией.
   - **Решение (псевдокод):**
     1. Объявить функцию `make_counter`.
     2. Внутри `make_counter` создать переменную `count` и присвоить ей 0.
     3. Внутри `make_counter` объявить функцию `increment`.
     4. Внутри `increment` указать, что переменная `count` не является локальной для `increment`, а берется из внешней области видимости (используйте ключевое слово `nonlocal`, если оно есть в языке, или аналогичный механизм).
     5. В теле `increment` увеличить `count` на 1.
     6. Вернуть значение `count`.
     7. Функция `make_counter` должна вернуть саму функцию `increment` (не вызывать ее, а вернуть как объект).
   - **Рекомендации:**
     - Это задание демонстрирует замыкание. Внутренняя функция `increment` "запоминает" переменную `count` из внешней функции `make_counter`.
     - Каждый вызов `make_counter()` создает новую независимую пару (`count`, `increment`).
