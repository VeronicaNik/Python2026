# Практическое задание 35.3

## Задания

### Описание задачи
В предыдущем блоке ты научилась работать с позиционными и именованными аргументами, а также значениями по умолчанию. Сейчас мы переходим к созданию гибких функций, которые могут принимать переменное количество данных. Это часто нужно, когда заранее неизвестно, сколько именно аргументов передаст пользователь.

Твоя задача — написать функцию `collect_data`, которая собирает информацию о студентах. Функция должна уметь принимать обязательные данные (имя и возраст), а также любое количество дополнительных сведений, таких как город, курс, хобби и т.д. Эти дополнительные сведения могут передаваться как позиционные аргументы (например, теги) и как именованные аргументы (например, метаданные).

**Контекст:** Представь, что ты пишешь модуль для учебной платформы. Нужно обрабатывать анкеты студентов, где всегда есть имя и возраст, а остальная информация — опциональна и может быть разного объема.

### Пример входных и выходных данных

**Пример 1: Базовый вызов**
```python
student1 = collect_data("Анна", 20)
print(student1)
```
**Ожидаемый вывод:**
```python
{
    'name': 'Анна',
    'age': 20,
    'tags': (),
    'details': {}
}
```

**Пример 2: С тегами и деталями**
```python
student2 = collect_data("Игорь", 22, "программирование", "математика", city="Казань", course=2)
print(student2)
```
**Ожидаемый вывод:**
```python
{
    'name': 'Игорь',
    'age': 22,
    'tags': ('программирование', 'математика'),
    'details': {'city': 'Казань', 'course': 2}
}
```

**Пример 3: Использование распаковки**
Предположим, у тебя уже есть списки и словари с данными.
```python
my_tags = ["спорт", "музыка"]
my_details = {"scholarship": True}
student3 = collect_data("Мария", 19, *my_tags, **my_details)
print(student3)
```
**Ожидаемый вывод:**
```python
{
    'name': 'Мария',
    'age': 19,
    'tags': ('спорт', 'музыка'),
    'details': {'scholarship': True}
}
```
**Пояснение к примерам:**
*   `*my_tags` распаковывает список `["спорт", "музыка"]` в два позиционных аргумента, которые функция `collect_data` соберет в кортеж `tags`.
*   `**my_details` распаковывает словарь `{"scholarship": True}` в именованные аргументы, которые функция соберет в словарь `details`.

### Критерии проверки и ограничения
1.  Функция должна называться `collect_data`.
2.  Первые два параметра должны быть `name` (строка) и `age` (целое число). Они обязательны.
3.  После `name` и `age` функция должна использовать `*tags` для сбора всех оставшихся позиционных аргументов в кортеж.
4.  После `*tags` функция должна использовать `**details` для сбора всех оставшихся именованных аргументов в словарь.
5.  Функция должна возвращать один словарь с ключами: `'name'`, `'age'`, `'tags'`, `'details'`.
6.  **Важно:** Используй только темы текущего блока: `*args`, `**kwargs`, переменное число аргументов, распаковка, кортеж, словарь. Не используй темы из будущих блоков, такие как область видимости, глобальные переменные, замыкание.

### Решение задачи (псевдокод)
1.  Объяви функцию `collect_data` с параметрами: `name`, `age`, `*tags`, `**details`.
2.  Внутри функции создай пустой словарь `result`.
3.  Добавь в словарь `result` пару ключ-значение для имени (`name`).
4.  Добавь в словарь `result` пару ключ-значение для возраста (`age`).
5.  Добавь в словарь `result` пару ключ-значение для тегов (`tags`). Значением будет кортеж, собранный параметром `*tags`.
6.  Добавь в словарь `result` пару ключ-значение для деталей (`details`). Значением будет словарь, собранный параметром `**details`.
7.  Верни словарь `result` из функции.

### Рекомендации
*   **Вынести в отдельную функцию:** В данном случае вся логика проста и умещается в одной функции `collect_data`. Выносить что-то еще не требуется.
*   **PEP8:**
    *   Названия функций должны быть в `snake_case` (все слова строчными буквами с подчеркиванием), что ты уже сделала, используя `collect_data`.
    *   После запятой при перечислении параметров функции ставь пробел: `def collect_data(name, age, *tags, **details):`
