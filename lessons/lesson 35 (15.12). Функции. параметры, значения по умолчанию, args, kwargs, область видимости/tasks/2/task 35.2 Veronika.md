# Практическое задание 35.2

Это задание относится ко второму блоку урока, посвященному управлению аргументами. В предыдущем блоке вы научились объявлять функции, передавать аргументы и возвращать результат. Сейчас мы сосредоточимся на использовании значений по умолчанию для параметров, включая безопасную работу с изменяемыми типами данных, а также закрепим правила порядка передачи позиционных и именованных аргументов. Это подготовит вас к более сложным сценариям работы с функциями.

## Задания

### Описание задачи
Вы помогаете разработать простую систему для управления списком задач (to-do list). Нужно создать функцию `add_task`, которая добавляет новую задачу в общий список. У задачи есть обязательное название и опциональные параметры: приоритет (число) и список тегов. Список задач должен быть общим для всех вызовов функции, но при этом нужно избежать типичной ошибки с изменяемым значением по умолчанию. Также важно, чтобы функция корректно работала при разном порядке передачи аргументов.

**Требования к функции `add_task`:**
1.  **Параметры:**
    *   `title` (обязательный, строка): название задачи.
    *   `priority` (необязательный, целое число): приоритет задачи. По умолчанию должен быть `1`.
    *   `tags` (необязательный, список строк): теги для задачи. По умолчанию должен быть пустым списком, но нужно использовать безопасный паттерн, чтобы списки задач между вызовами не смешивались.
    *   `task_list` (необязательный, список): общий список, в который добавляется задача. Для этого параметра также необходимо применить безопасный паттерн со значением по умолчанию.
2.  **Логика:** Функция должна создать словарь, представляющий задачу, с ключами `'title'`, `'priority'` и `'tags'`, и добавить этот словарь в переданный список `task_list`. Функция должна возвращать обновленный список `task_list`.
3.  **Порядок аргументов:** Функция должна корректно обрабатывать вызовы как с позиционными, так и с именованными аргументами в правильном порядке.

### Пример входных и выходных данных

**Пример 1: Базовый вызов с позиционными аргументами**
```python
my_tasks = []
result = add_task("Купить молоко", 2, ["еда", "магазин"], my_tasks)
print(result)
```
**Ожидаемый вывод:**
```
[{'title': 'Купить молоко', 'priority': 2, 'tags': ['еда', 'магазин']}]
```
*Пояснение:* Все аргументы переданы позиционно. Создается задача с указанными параметрами и добавляется в переданный пустой список `my_tasks`.

**Пример 2: Вызов с именованными аргументами и изменением порядка**
```python
my_tasks = []
result = add_task(title="Позвонить маме", tags=["семья"], task_list=my_tasks)
print(result)
```
**Ожидаемый вывод:**
```
[{'title': 'Позвонить маме', 'priority': 1, 'tags': ['семья']}]
```
*Пояснение:* Аргументы переданы по имени, порядок не важен. Параметр `priority` не передан, поэтому используется значение по умолчанию `1`.

**Пример 3: Проверка безопасного значения по умолчанию**
```python
# Первый вызов без передачи task_list
list1 = add_task("Задача 1")
print("List1:", list1)

# Второй вызов без передачи task_list
list2 = add_task("Задача 2")
print("List2:", list2)

# Сравнение: list1 и list2 должны быть РАЗНЫМИ списками
print("list1 is list2?", list1 is list2) # Должно быть False
```
**Ожидаемый вывод:**
```
List1: [{'title': 'Задача 1', 'priority': 1, 'tags': []}]
List2: [{'title': 'Задача 2', 'priority': 1, 'tags': []}]
list1 is list2? False
```
*Пояснение:* Ключевая проверка. Если паттерн `None` для `task_list` реализован правильно, каждый вызов без явного указания списка создаст новый независимый список. Если же допущена ошибка (например, `task_list=[]` прямо в параметрах), то `list1` и `list2` будут одним и тем же списком, и вторая задача добавится к первой.

### Критерии проверки и ограничения
1.  Функция `add_task` должна строго соответствовать объявленным параметрам и их порядку.
2.  Для параметров `tags` и `task_list` **обязательно** должен быть использован безопасный паттерн со значением по умолчанию `None` и созданием нового списка внутри функции.
3.  Параметр `priority` должен иметь простое значение по умолчанию `1`.
4.  Функция должна возвращать список (обновленный `task_list`).
5.  **Запрещено использовать:** `*args`, `**kwargs`, распаковку, кортежи и словари для сбора аргументов, а также любые темы, связанные с областью видимости (кроме базового понимания передачи аргументов).

### Решение задачи (псевдокод)
1.  Объяви функцию `add_task` с параметрами: `title`, `priority` (по умолчанию 1), `tags` (по умолчанию None), `task_list` (по умолчанию None).
2.  Внутри функции:
    a.  Если `task_list` равно None, создать новый пустой список и присвоить его переменной `task_list`.
    b.  Если `tags` равно None, создать новый пустой список и присвоить его локальной переменной (например, `task_tags`).
    c.  Создать словарь `new_task` с ключами: 'title' (значение из `title`), 'priority' (значение из `priority`), 'tags' (значение из `tags` или созданного пустого списка).
    d.  Добавить словарь `new_task` в конец списка `task_list`.
    e.  Вернуть список `task_list` как результат функции.

### Рекомендации
-   **Вынести в отдельную функцию:** В данном случае вся логика сосредоточена в одной операции — добавлении задачи. Создавать дополнительные функции не требуется.
-   **PEP8:**
    -   Используйте пробелы вокруг оператора присваивания (`=`) при объявлении параметров по умолчанию: `def add_task(title, priority=1, tags=None, task_list=None):`.
    -   Для проверки на `None` используйте оператор `is`: `if tags is None:`.
